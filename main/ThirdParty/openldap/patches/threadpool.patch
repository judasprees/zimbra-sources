From f230503b108b1c1fd2dec072b0ad5d6785da4968 Mon Sep 17 00:00:00 2001
From: Howard Chu <hyc@openldap.org>
Date: Fri, 16 Aug 2013 18:56:31 -0700
Subject: [PATCH] Tweak mutex acquisition

Slightly reduce held time.
---
 servers/slapd/ctxcsn.c    |    8 ++++----
 servers/slapd/operation.c |    2 +-
 2 files changed, 5 insertions(+), 5 deletions(-)

diff --git a/servers/slapd/ctxcsn.c b/servers/slapd/ctxcsn.c
index c67bc88..1331f33 100644
--- a/servers/slapd/ctxcsn.c
+++ b/servers/slapd/ctxcsn.c
@@ -50,12 +50,12 @@ slap_get_commit_csn(
 		*foundit = 0;
 	}
 
-	ldap_pvt_thread_mutex_lock( &be->be_pcl_mutex );
-
 	if ( !BER_BVISEMPTY( &op->o_csn )) {
 		sid = slap_parse_csn_sid( &op->o_csn );
 	}
 
+	ldap_pvt_thread_mutex_lock( &be->be_pcl_mutex );
+
 	LDAP_TAILQ_FOREACH( csne, be->be_pending_csn_list, ce_csn_link ) {
 		if ( csne->ce_opid == op->o_opid && csne->ce_connid == op->o_connid ) {
 			csne->ce_state = SLAP_CSN_COMMIT;
@@ -188,14 +188,14 @@ slap_queue_csn(
 
 	Debug( LDAP_DEBUG_SYNC, "slap_queue_csn: queing %p %s\n", csn->bv_val, csn->bv_val, 0 );
 
-	ldap_pvt_thread_mutex_lock( &be->be_pcl_mutex );
-
 	ber_dupbv( &pending->ce_csn, csn );
 	ber_bvreplace_x( &op->o_csn, &pending->ce_csn, op->o_tmpmemctx );
 	pending->ce_sid = slap_parse_csn_sid( csn );
 	pending->ce_connid = op->o_connid;
 	pending->ce_opid = op->o_opid;
 	pending->ce_state = SLAP_CSN_PENDING;
+
+	ldap_pvt_thread_mutex_lock( &be->be_pcl_mutex );
 	LDAP_TAILQ_INSERT_TAIL( be->be_pending_csn_list,
 		pending, ce_csn_link );
 	ldap_pvt_thread_mutex_unlock( &be->be_pcl_mutex );
diff --git a/servers/slapd/operation.c b/servers/slapd/operation.c
index a2644ef..1d83ffd 100644
--- a/servers/slapd/operation.c
+++ b/servers/slapd/operation.c
@@ -159,8 +159,8 @@ slap_op_free( Operation *op, void *ctx )
 void
 slap_op_time(time_t *t, int *nop)
 {
-	ldap_pvt_thread_mutex_lock( &slap_op_mutex );
 	*t = slap_get_time();
+	ldap_pvt_thread_mutex_lock( &slap_op_mutex );
 	if ( *t == last_time ) {
 		*nop = ++last_incr;
 	} else {
-- 
1.7.4.2

From 34f832faee9f215dfdb61de52506f2905258b147 Mon Sep 17 00:00:00 2001
From: Howard Chu <hyc@openldap.org>
Date: Thu, 15 Aug 2013 06:54:35 -0700
Subject: [PATCH] Multiple queues per threadpool

---
 include/ldap_pvt_thread.h   |    7 +
 libraries/libldap_r/tpool.c |  480 +++++++++++++++++++++++++++++--------------
 servers/slapd/bconfig.c     |   31 +++-
 servers/slapd/init.c        |    7 +-
 servers/slapd/proto-slap.h  |    1 +
 5 files changed, 362 insertions(+), 164 deletions(-)

diff --git a/include/ldap_pvt_thread.h b/include/ldap_pvt_thread.h
index 52d048a..e57caf8 100644
--- a/include/ldap_pvt_thread.h
+++ b/include/ldap_pvt_thread.h
@@ -214,6 +214,13 @@ ldap_pvt_thread_pool_init LDAP_P((
 	int max_pending ));
 
 LDAP_F( int )
+ldap_pvt_thread_pool_init_q LDAP_P((
+	ldap_pvt_thread_pool_t *pool_out,
+	int max_threads,
+	int max_pending,
+	int num_qs ));
+
+LDAP_F( int )
 ldap_pvt_thread_pool_submit LDAP_P((
 	ldap_pvt_thread_pool_t *pool,
 	ldap_pvt_thread_start_t *start,
diff --git a/libraries/libldap_r/tpool.c b/libraries/libldap_r/tpool.c
index 87e9594..23a0624 100644
--- a/libraries/libldap_r/tpool.c
+++ b/libraries/libldap_r/tpool.c
@@ -55,6 +55,7 @@ enum { NOT_PAUSED = 0, WANT_PAUSE = 1, PAUSED = 2 };
 
 /* Context: thread ID and thread-specific key/data pairs */
 typedef struct ldap_int_thread_userctx_s {
+	struct ldap_int_thread_poolq_s *ltu_pq;
 	ldap_pvt_thread_t ltu_id;
 	ldap_int_tpool_key_t ltu_key[MAXKEYS];
 } ldap_int_thread_userctx_t;
@@ -91,8 +92,8 @@ typedef struct ldap_int_thread_task_s {
 
 typedef LDAP_STAILQ_HEAD(tcq, ldap_int_thread_task_s) ldap_int_tpool_plist_t;
 
-struct ldap_int_thread_pool_s {
-	LDAP_STAILQ_ENTRY(ldap_int_thread_pool_s) ltp_next;
+struct ldap_int_thread_poolq_s {
+	struct ldap_int_thread_pool_s *ltp_pool;
 
 	/* protect members below, and protect thread_keys[] during pauses */
 	ldap_pvt_thread_mutex_t ltp_mutex;
@@ -112,6 +113,29 @@ struct ldap_int_thread_pool_s {
 	ldap_int_tpool_plist_t ltp_pending_list;
 	LDAP_SLIST_HEAD(tcl, ldap_int_thread_task_s) ltp_free_list;
 
+	/* Max number of threads in pool, or 0 for default (LDAP_MAXTHR) */
+	int ltp_max_count;
+
+	/* Max pending + paused + idle tasks, negated when ltp_finishing */
+	int ltp_max_pending;
+
+	int ltp_pending_count;		/* Pending + paused + idle tasks */
+	int ltp_active_count;		/* Active, not paused/idle tasks */
+	int ltp_open_count;			/* Number of threads, negated when ltp_pause */
+	int ltp_starting;			/* Currently starting threads */
+};
+
+struct ldap_int_thread_pool_s {
+	LDAP_STAILQ_ENTRY(ldap_int_thread_pool_s) ltp_next;
+
+	struct ldap_int_thread_poolq_s *ltp_wqs;
+
+	/* number of poolqs */
+	int ltp_numqs;
+
+	/* protect members below, and protect thread_keys[] during pauses */
+	ldap_pvt_thread_mutex_t ltp_mutex;
+
 	/* The pool is finishing, waiting for its threads to close.
 	 * They close when ltp_pending_list is done.  pool_submit()
 	 * rejects new tasks.  ltp_max_pending = -(its old value).
@@ -120,34 +144,17 @@ struct ldap_int_thread_pool_s {
 
 	/* Some active task needs to be the sole active task.
 	 * Atomic variable so ldap_pvt_thread_pool_pausing() can read it.
-	 * Note: Pauses adjust ltp_<open_count/vary_open_count/work_list>,
-	 * so pool_<submit/wrapper>() mostly can avoid testing ltp_pause.
 	 */
 	volatile sig_atomic_t ltp_pause;
 
-	/* Max number of threads in pool, or 0 for default (LDAP_MAXTHR) */
+	/* Max number of threads in pool */
 	int ltp_max_count;
 
+	/* Configured max number of threads in pool, 0 for default (LDAP_MAXTHR) */
+	int ltp_conf_max_count;
+
 	/* Max pending + paused + idle tasks, negated when ltp_finishing */
 	int ltp_max_pending;
-
-	int ltp_pending_count;		/* Pending + paused + idle tasks */
-	int ltp_active_count;		/* Active, not paused/idle tasks */
-	int ltp_open_count;			/* Number of threads, negated when ltp_pause */
-	int ltp_starting;			/* Currenlty starting threads */
-
-	/* >0 if paused or we may open a thread, <0 if we should close a thread.
-	 * Updated when ltp_<finishing/pause/max_count/open_count> change.
-	 * Maintained to reduce the time ltp_mutex must be locked in
-	 * ldap_pvt_thread_pool_<submit/wrapper>().
-	 */
-	int ltp_vary_open_count;
-#	define SET_VARY_OPEN_COUNT(pool)	\
-		((pool)->ltp_vary_open_count =	\
-		 (pool)->ltp_pause      ?  1 :	\
-		 (pool)->ltp_finishing  ? -1 :	\
-		 ((pool)->ltp_max_count ? (pool)->ltp_max_count : LDAP_MAXTHR) \
-		 - (pool)->ltp_open_count)
 };
 
 static ldap_int_tpool_plist_t empty_pending_list =
@@ -191,13 +198,15 @@ ldap_int_thread_pool_shutdown ( void )
 
 /* Create a thread pool */
 int
-ldap_pvt_thread_pool_init (
+ldap_pvt_thread_pool_init_q (
 	ldap_pvt_thread_pool_t *tpool,
 	int max_threads,
-	int max_pending )
+	int max_pending,
+	int numqs )
 {
 	ldap_pvt_thread_pool_t pool;
-	int rc;
+	struct ldap_int_thread_poolq_s *pq;
+	int i, rc, rem_thr, rem_pend;
 
 	/* multiple pools are currently not supported (ITS#4943) */
 	assert(!ldap_int_has_thread_pool);
@@ -209,30 +218,56 @@ ldap_pvt_thread_pool_init (
 
 	*tpool = NULL;
 	pool = (ldap_pvt_thread_pool_t) LDAP_CALLOC(1,
-		sizeof(struct ldap_int_thread_pool_s));
+		sizeof(struct ldap_int_thread_pool_s) +
+		numqs * sizeof(struct ldap_int_thread_poolq_s));
 
 	if (pool == NULL) return(-1);
 
+	pool->ltp_wqs = (struct ldap_int_thread_poolq_s *)(pool+1);
+	pool->ltp_numqs = numqs;
+	pool->ltp_conf_max_count = max_threads;
+	if ( !max_threads )
+		max_threads = LDAP_MAXTHR;
+
 	rc = ldap_pvt_thread_mutex_init(&pool->ltp_mutex);
 	if (rc != 0)
 		return(rc);
-	rc = ldap_pvt_thread_cond_init(&pool->ltp_cond);
-	if (rc != 0)
-		return(rc);
-	rc = ldap_pvt_thread_cond_init(&pool->ltp_pcond);
-	if (rc != 0)
-		return(rc);
+
+	rem_thr = max_threads % numqs;
+	rem_pend = max_pending % numqs;
+	for ( i=0; i<numqs; i++ ) {
+		pq = &pool->ltp_wqs[i];
+		pq->ltp_pool = pool;
+		rc = ldap_pvt_thread_mutex_init(&pq->ltp_mutex);
+		if (rc != 0)
+			return(rc);
+		rc = ldap_pvt_thread_cond_init(&pq->ltp_cond);
+		if (rc != 0)
+			return(rc);
+		rc = ldap_pvt_thread_cond_init(&pq->ltp_pcond);
+		if (rc != 0)
+			return(rc);
+		LDAP_STAILQ_INIT(&pq->ltp_pending_list);
+		pq->ltp_work_list = &pq->ltp_pending_list;
+		LDAP_SLIST_INIT(&pq->ltp_free_list);
+
+		pq->ltp_max_count = max_threads / numqs;
+		if ( rem_thr ) {
+			pq->ltp_max_count++;
+			rem_thr--;
+		}
+		pq->ltp_max_pending = max_pending / numqs;
+		if ( rem_pend ) {
+			pq->ltp_max_pending++;
+			rem_pend--;
+		}
+	}
 
 	ldap_int_has_thread_pool = 1;
 
 	pool->ltp_max_count = max_threads;
-	SET_VARY_OPEN_COUNT(pool);
 	pool->ltp_max_pending = max_pending;
 
-	LDAP_STAILQ_INIT(&pool->ltp_pending_list);
-	pool->ltp_work_list = &pool->ltp_pending_list;
-	LDAP_SLIST_INIT(&pool->ltp_free_list);
-
 	ldap_pvt_thread_mutex_lock(&ldap_pvt_thread_pool_mutex);
 	LDAP_STAILQ_INSERT_TAIL(&ldap_int_thread_pool_list, pool, ltp_next);
 	ldap_pvt_thread_mutex_unlock(&ldap_pvt_thread_pool_mutex);
@@ -248,6 +283,28 @@ ldap_pvt_thread_pool_init (
 	return(0);
 }
 
+int
+ldap_pvt_thread_pool_init (
+	ldap_pvt_thread_pool_t *tpool,
+	int max_threads,
+	int max_pending )
+{
+	return ldap_pvt_thread_pool_init_q( tpool, max_threads, max_pending, 1 );
+}
+
+static int
+ldap_int_poolq_hash(
+	struct ldap_int_thread_pool_s *pool,
+	void *arg )
+{
+	int i = 0, j;
+	unsigned char *ptr = (unsigned char *)&arg;
+	/* dumb hash of arg to choose a queue */
+	for (j=0; j<sizeof(arg); j++)
+		i += *ptr++;
+	i %= pool->ltp_numqs;
+	return i;
+}
 
 /* Submit a task to be performed by the thread pool */
 int
@@ -256,8 +313,10 @@ ldap_pvt_thread_pool_submit (
 	ldap_pvt_thread_start_t *start_routine, void *arg )
 {
 	struct ldap_int_thread_pool_s *pool;
+	struct ldap_int_thread_poolq_s *pq;
 	ldap_int_thread_task_t *task;
 	ldap_pvt_thread_t thr;
+	int i, j;
 
 	if (tpool == NULL)
 		return(-1);
@@ -267,14 +326,28 @@ ldap_pvt_thread_pool_submit (
 	if (pool == NULL)
 		return(-1);
 
-	ldap_pvt_thread_mutex_lock(&pool->ltp_mutex);
+	if ( pool->ltp_numqs > 1 )
+		i = ldap_int_poolq_hash( pool, arg );
+	else
+		i = 0;
 
-	if (pool->ltp_pending_count >= pool->ltp_max_pending)
-		goto failed;
+	j = i;
+	while(1) {
+		ldap_pvt_thread_mutex_lock(&pool->ltp_wqs[i].ltp_mutex);
+		if (pool->ltp_wqs[i].ltp_pending_count < pool->ltp_wqs[i].ltp_max_pending) {
+			break;
+		}
+		ldap_pvt_thread_mutex_unlock(&pool->ltp_wqs[i].ltp_mutex);
+		i++;
+		i %= pool->ltp_numqs;
+		if ( i == j )
+			return -1;
+	}
 
-	task = LDAP_SLIST_FIRST(&pool->ltp_free_list);
+	pq = &pool->ltp_wqs[i];
+	task = LDAP_SLIST_FIRST(&pq->ltp_free_list);
 	if (task) {
-		LDAP_SLIST_REMOVE_HEAD(&pool->ltp_free_list, ltt_next.l);
+		LDAP_SLIST_REMOVE_HEAD(&pq->ltp_free_list, ltt_next.l);
 	} else {
 		task = (ldap_int_thread_task_t *) LDAP_MALLOC(sizeof(*task));
 		if (task == NULL)
@@ -284,49 +357,47 @@ ldap_pvt_thread_pool_submit (
 	task->ltt_start_routine = start_routine;
 	task->ltt_arg = arg;
 
-	pool->ltp_pending_count++;
-	LDAP_STAILQ_INSERT_TAIL(&pool->ltp_pending_list, task, ltt_next.q);
+	pq->ltp_pending_count++;
+	LDAP_STAILQ_INSERT_TAIL(&pq->ltp_pending_list, task, ltt_next.q);
 
-	/* true if ltp_pause != 0 or we should open (create) a thread */
-	if (pool->ltp_vary_open_count > 0 &&
-		pool->ltp_open_count < pool->ltp_active_count+pool->ltp_pending_count)
+	/* should we open (create) a thread? */
+	if (pq->ltp_open_count < pq->ltp_active_count+pq->ltp_pending_count &&
+		pq->ltp_open_count < pq->ltp_max_count)
 	{
 		if (pool->ltp_pause)
 			goto done;
 
-		pool->ltp_starting++;
-		pool->ltp_open_count++;
-		SET_VARY_OPEN_COUNT(pool);
+		pq->ltp_starting++;
+		pq->ltp_open_count++;
 
 		if (0 != ldap_pvt_thread_create(
-			&thr, 1, ldap_int_thread_pool_wrapper, pool))
+			&thr, 1, ldap_int_thread_pool_wrapper, pq))
 		{
 			/* couldn't create thread.  back out of
 			 * ltp_open_count and check for even worse things.
 			 */
-			pool->ltp_starting--;
-			pool->ltp_open_count--;
-			SET_VARY_OPEN_COUNT(pool);
+			pq->ltp_starting--;
+			pq->ltp_open_count--;
 
-			if (pool->ltp_open_count == 0) {
+			if (pq->ltp_open_count == 0) {
 				/* no open threads at all?!?
 				 */
 				ldap_int_thread_task_t *ptr;
 
 				/* let pool_destroy know there are no more threads */
-				ldap_pvt_thread_cond_signal(&pool->ltp_cond);
+				ldap_pvt_thread_cond_signal(&pq->ltp_cond);
 
-				LDAP_STAILQ_FOREACH(ptr, &pool->ltp_pending_list, ltt_next.q)
+				LDAP_STAILQ_FOREACH(ptr, &pq->ltp_pending_list, ltt_next.q)
 					if (ptr == task) break;
 				if (ptr == task) {
 					/* no open threads, task not handled, so
 					 * back out of ltp_pending_count, free the task,
 					 * report the error.
 					 */
-					pool->ltp_pending_count--;
-					LDAP_STAILQ_REMOVE(&pool->ltp_pending_list, task,
+					pq->ltp_pending_count--;
+					LDAP_STAILQ_REMOVE(&pq->ltp_pending_list, task,
 						ldap_int_thread_task_s, ltt_next.q);
-					LDAP_SLIST_INSERT_HEAD(&pool->ltp_free_list, task,
+					LDAP_SLIST_INSERT_HEAD(&pq->ltp_free_list, task,
 						ltt_next.l);
 					goto failed;
 				}
@@ -336,14 +407,14 @@ ldap_pvt_thread_pool_submit (
 			 */
 		}
 	}
-	ldap_pvt_thread_cond_signal(&pool->ltp_cond);
+	ldap_pvt_thread_cond_signal(&pq->ltp_cond);
 
  done:
-	ldap_pvt_thread_mutex_unlock(&pool->ltp_mutex);
+	ldap_pvt_thread_mutex_unlock(&pq->ltp_mutex);
 	return(0);
 
  failed:
-	ldap_pvt_thread_mutex_unlock(&pool->ltp_mutex);
+	ldap_pvt_thread_mutex_unlock(&pq->ltp_mutex);
 	return(-1);
 }
 
@@ -363,7 +434,9 @@ ldap_pvt_thread_pool_retract (
 	ldap_pvt_thread_start_t *start_routine, void *arg )
 {
 	struct ldap_int_thread_pool_s *pool;
+	struct ldap_int_thread_poolq_s *pq;
 	ldap_int_thread_task_t *task;
+	int i;
 
 	if (tpool == NULL)
 		return(-1);
@@ -373,8 +446,11 @@ ldap_pvt_thread_pool_retract (
 	if (pool == NULL)
 		return(-1);
 
-	ldap_pvt_thread_mutex_lock(&pool->ltp_mutex);
-	LDAP_STAILQ_FOREACH(task, &pool->ltp_pending_list, ltt_next.q)
+	i = ldap_int_poolq_hash( pool, arg );
+	pq = &pool->ltp_wqs[i];
+
+	ldap_pvt_thread_mutex_lock(&pq->ltp_mutex);
+	LDAP_STAILQ_FOREACH(task, &pq->ltp_pending_list, ltt_next.q)
 		if (task->ltt_start_routine == start_routine &&
 			task->ltt_arg == arg) {
 			/* Could LDAP_STAILQ_REMOVE the task, but that
@@ -384,7 +460,7 @@ ldap_pvt_thread_pool_retract (
 			task->ltt_arg = NULL;
 			break;
 		}
-	ldap_pvt_thread_mutex_unlock(&pool->ltp_mutex);
+	ldap_pvt_thread_mutex_unlock(&pq->ltp_mutex);
 	return task != NULL;
 }
 
@@ -395,6 +471,8 @@ ldap_pvt_thread_pool_maxthreads(
 	int max_threads )
 {
 	struct ldap_int_thread_pool_s *pool;
+	struct ldap_int_thread_poolq_s *pq;
+	int remthr, i;
 
 	if (! (0 <= max_threads && max_threads <= LDAP_MAXTHR))
 		max_threads = 0;
@@ -407,12 +485,24 @@ ldap_pvt_thread_pool_maxthreads(
 	if (pool == NULL)
 		return(-1);
 
-	ldap_pvt_thread_mutex_lock(&pool->ltp_mutex);
-
+	pool->ltp_conf_max_count = max_threads;
+	if ( !max_threads )
+		max_threads = LDAP_MAXTHR;
 	pool->ltp_max_count = max_threads;
-	SET_VARY_OPEN_COUNT(pool);
 
-	ldap_pvt_thread_mutex_unlock(&pool->ltp_mutex);
+	remthr = max_threads % pool->ltp_numqs;
+	max_threads /= pool->ltp_numqs;
+
+	for (i=0; i<pool->ltp_numqs; i++) {
+		pq = &pool->ltp_wqs[i];
+		ldap_pvt_thread_mutex_lock(&pq->ltp_mutex);
+		pq->ltp_max_count = max_threads;
+		if (remthr) {
+			pq->ltp_max_count++;
+			remthr--;
+		}
+		ldap_pvt_thread_mutex_unlock(&pq->ltp_mutex);
+	}
 	return(0);
 }
 
@@ -436,10 +526,9 @@ ldap_pvt_thread_pool_query(
 		return 0;
 	}
 
-	ldap_pvt_thread_mutex_lock(&pool->ltp_mutex);
 	switch ( param ) {
 	case LDAP_PVT_THREAD_POOL_PARAM_MAX:
-		count = pool->ltp_max_count;
+		count = pool->ltp_conf_max_count;
 		break;
 
 	case LDAP_PVT_THREAD_POOL_PARAM_MAX_PENDING:
@@ -450,30 +539,45 @@ ldap_pvt_thread_pool_query(
 			count = 0;
 		break;
 
-	case LDAP_PVT_THREAD_POOL_PARAM_OPEN:
-		count = pool->ltp_open_count;
-		if (count < 0)
-			count = -count;
-		break;
-
-	case LDAP_PVT_THREAD_POOL_PARAM_STARTING:
-		count = pool->ltp_starting;
-		break;
-
-	case LDAP_PVT_THREAD_POOL_PARAM_ACTIVE:
-		count = pool->ltp_active_count;
-		break;
-
 	case LDAP_PVT_THREAD_POOL_PARAM_PAUSING:
+		ldap_pvt_thread_mutex_lock(&pool->ltp_mutex);
 		count = (pool->ltp_pause != 0);
+		ldap_pvt_thread_mutex_unlock(&pool->ltp_mutex);
 		break;
 
+	case LDAP_PVT_THREAD_POOL_PARAM_OPEN:
+	case LDAP_PVT_THREAD_POOL_PARAM_STARTING:
+	case LDAP_PVT_THREAD_POOL_PARAM_ACTIVE:
 	case LDAP_PVT_THREAD_POOL_PARAM_PENDING:
-		count = pool->ltp_pending_count;
-		break;
-
 	case LDAP_PVT_THREAD_POOL_PARAM_BACKLOAD:
-		count = pool->ltp_pending_count + pool->ltp_active_count;
+		{
+			int i;
+			count = 0;
+			for (i=0; i<pool->ltp_numqs; i++) {
+				struct ldap_int_thread_poolq_s *pq = &pool->ltp_wqs[i];
+				ldap_pvt_thread_mutex_lock(&pq->ltp_mutex);
+				switch(param) {
+					case LDAP_PVT_THREAD_POOL_PARAM_OPEN:
+						count += pq->ltp_open_count;
+						break;
+					case LDAP_PVT_THREAD_POOL_PARAM_STARTING:
+						count += pq->ltp_starting;
+						break;
+					case LDAP_PVT_THREAD_POOL_PARAM_ACTIVE:
+						count += pq->ltp_active_count;
+						break;
+					case LDAP_PVT_THREAD_POOL_PARAM_PENDING:
+						count += pq->ltp_pending_count;
+						break;
+					case LDAP_PVT_THREAD_POOL_PARAM_BACKLOAD:
+						count += pq->ltp_pending_count + pq->ltp_active_count;
+						break;
+				}
+				ldap_pvt_thread_mutex_unlock(&pq->ltp_mutex);
+			}
+			if (count < 0)
+				count = -count;
+		}
 		break;
 
 	case LDAP_PVT_THREAD_POOL_PARAM_ACTIVE_MAX:
@@ -486,16 +590,24 @@ ldap_pvt_thread_pool_query(
 		break;
 
 	case LDAP_PVT_THREAD_POOL_PARAM_STATE:
-		*((char **)value) =
-			pool->ltp_pause ? "pausing" :
-			!pool->ltp_finishing ? "running" :
-			pool->ltp_pending_count ? "finishing" : "stopping";
+		if (pool->ltp_pause)
+			*((char **)value) = "pausing";
+		else if (!pool->ltp_finishing)
+			*((char **)value) = "running";
+		else {
+			int i;
+			for (i=0; i<pool->ltp_numqs; i++)
+				if (pool->ltp_wqs[i].ltp_pending_count) break;
+			if (i<pool->ltp_numqs)
+				*((char **)value) = "finishing";
+			else
+				*((char **)value) = "stopping";
+		}
 		break;
 
 	case LDAP_PVT_THREAD_POOL_PARAM_UNKNOWN:
 		break;
 	}
-	ldap_pvt_thread_mutex_unlock( &pool->ltp_mutex );
 
 	if ( count > -1 ) {
 		*((int *)value) = count;
@@ -545,7 +657,9 @@ int
 ldap_pvt_thread_pool_destroy ( ldap_pvt_thread_pool_t *tpool, int run_pending )
 {
 	struct ldap_int_thread_pool_s *pool, *pptr;
+	struct ldap_int_thread_poolq_s *pq;
 	ldap_int_thread_task_t *task;
+	int i;
 
 	if (tpool == NULL)
 		return(-1);
@@ -567,33 +681,40 @@ ldap_pvt_thread_pool_destroy ( ldap_pvt_thread_pool_t *tpool, int run_pending )
 	ldap_pvt_thread_mutex_lock(&pool->ltp_mutex);
 
 	pool->ltp_finishing = 1;
-	SET_VARY_OPEN_COUNT(pool);
 	if (pool->ltp_max_pending > 0)
 		pool->ltp_max_pending = -pool->ltp_max_pending;
 
-	if (!run_pending) {
-		while ((task = LDAP_STAILQ_FIRST(&pool->ltp_pending_list)) != NULL) {
-			LDAP_STAILQ_REMOVE_HEAD(&pool->ltp_pending_list, ltt_next.q);
-			LDAP_FREE(task);
+	for (i=0; i<pool->ltp_numqs; i++) {
+		pq = &pool->ltp_wqs[i];
+		ldap_pvt_thread_mutex_lock(&pq->ltp_mutex);
+		if (pq->ltp_max_pending > 0)
+			pq->ltp_max_pending = -pq->ltp_max_pending;
+		if (!run_pending) {
+			while ((task = LDAP_STAILQ_FIRST(&pq->ltp_pending_list)) != NULL) {
+				LDAP_STAILQ_REMOVE_HEAD(&pq->ltp_pending_list, ltt_next.q);
+				LDAP_FREE(task);
+			}
+			pq->ltp_pending_count = 0;
 		}
-		pool->ltp_pending_count = 0;
-	}
 
-	while (pool->ltp_open_count) {
-		if (!pool->ltp_pause)
-			ldap_pvt_thread_cond_broadcast(&pool->ltp_cond);
-		ldap_pvt_thread_cond_wait(&pool->ltp_cond, &pool->ltp_mutex);
-	}
+		while (pq->ltp_open_count) {
+			if (!pool->ltp_pause)
+				ldap_pvt_thread_cond_broadcast(&pq->ltp_cond);
+			ldap_pvt_thread_cond_wait(&pq->ltp_cond, &pq->ltp_mutex);
+		}
 
-	while ((task = LDAP_SLIST_FIRST(&pool->ltp_free_list)) != NULL)
-	{
-		LDAP_SLIST_REMOVE_HEAD(&pool->ltp_free_list, ltt_next.l);
-		LDAP_FREE(task);
+		while ((task = LDAP_SLIST_FIRST(&pq->ltp_free_list)) != NULL)
+		{
+			LDAP_SLIST_REMOVE_HEAD(&pq->ltp_free_list, ltt_next.l);
+			LDAP_FREE(task);
+		}
+		ldap_pvt_thread_mutex_unlock(&pq->ltp_mutex);
+		ldap_pvt_thread_cond_destroy(&pq->ltp_pcond);
+		ldap_pvt_thread_cond_destroy(&pq->ltp_cond);
+		ldap_pvt_thread_mutex_destroy(&pq->ltp_mutex);
 	}
 
 	ldap_pvt_thread_mutex_unlock(&pool->ltp_mutex);
-	ldap_pvt_thread_cond_destroy(&pool->ltp_pcond);
-	ldap_pvt_thread_cond_destroy(&pool->ltp_cond);
 	ldap_pvt_thread_mutex_destroy(&pool->ltp_mutex);
 	LDAP_FREE(pool);
 	*tpool = NULL;
@@ -606,7 +727,8 @@ static void *
 ldap_int_thread_pool_wrapper ( 
 	void *xpool )
 {
-	struct ldap_int_thread_pool_s *pool = xpool;
+	struct ldap_int_thread_poolq_s *pq = xpool;
+	struct ldap_int_thread_pool_s *pool = pq->ltp_pool;
 	ldap_int_thread_task_t *task;
 	ldap_int_tpool_plist_t *work_list;
 	ldap_int_thread_userctx_t ctx, *kctx;
@@ -618,16 +740,17 @@ ldap_int_thread_pool_wrapper (
 		ctx.ltu_key[i].ltk_key = NULL;
 	}
 
+	ctx.ltu_pq = pq;
 	ctx.ltu_id = ldap_pvt_thread_self();
 	TID_HASH(ctx.ltu_id, hash);
 
 	ldap_pvt_thread_key_setdata( ldap_tpool_key, &ctx );
 
-	ldap_pvt_thread_mutex_lock(&pool->ltp_mutex);
+	ldap_pvt_thread_mutex_lock(&pq->ltp_mutex);
 
 	/* thread_keys[] is read-only when paused */
 	while (pool->ltp_pause)
-		ldap_pvt_thread_cond_wait(&pool->ltp_cond, &pool->ltp_mutex);
+		ldap_pvt_thread_cond_wait(&pq->ltp_cond, &pq->ltp_mutex);
 
 	/* find a key slot to give this thread ID and store a
 	 * pointer to our keys there; start at the thread ID
@@ -640,20 +763,20 @@ ldap_int_thread_pool_wrapper (
 	thread_keys[keyslot].ctx = &ctx;
 	ldap_pvt_thread_mutex_unlock(&ldap_pvt_thread_pool_mutex);
 
-	pool->ltp_starting--;
-	pool->ltp_active_count++;
+	pq->ltp_starting--;
+	pq->ltp_active_count++;
 
 	for (;;) {
-		work_list = pool->ltp_work_list; /* help the compiler a bit */
+		work_list = pq->ltp_work_list; /* help the compiler a bit */
 		task = LDAP_STAILQ_FIRST(work_list);
 		if (task == NULL) {	/* paused or no pending tasks */
-			if (--(pool->ltp_active_count) < 2) {
+			if (--(pq->ltp_active_count) < 2) {
 				/* Notify pool_pause it is the sole active thread. */
-				ldap_pvt_thread_cond_signal(&pool->ltp_pcond);
+				ldap_pvt_thread_cond_signal(&pq->ltp_pcond);
 			}
 
 			do {
-				if (pool->ltp_vary_open_count < 0) {
+				if (pool->ltp_finishing || pq->ltp_open_count > pq->ltp_max_count) {
 					/* Not paused, and either finishing or too many
 					 * threads running (can happen if ltp_max_count
 					 * was reduced).  Let this thread die.
@@ -672,23 +795,23 @@ ldap_int_thread_pool_wrapper (
 				 * Just use pthread_cond_timedwait() if we want to
 				 * check idle time.
 				 */
-				ldap_pvt_thread_cond_wait(&pool->ltp_cond, &pool->ltp_mutex);
+				ldap_pvt_thread_cond_wait(&pq->ltp_cond, &pq->ltp_mutex);
 
-				work_list = pool->ltp_work_list;
+				work_list = pq->ltp_work_list;
 				task = LDAP_STAILQ_FIRST(work_list);
 			} while (task == NULL);
 
-			pool->ltp_active_count++;
+			pq->ltp_active_count++;
 		}
 
 		LDAP_STAILQ_REMOVE_HEAD(work_list, ltt_next.q);
-		pool->ltp_pending_count--;
-		ldap_pvt_thread_mutex_unlock(&pool->ltp_mutex);
+		pq->ltp_pending_count--;
+		ldap_pvt_thread_mutex_unlock(&pq->ltp_mutex);
 
 		task->ltt_start_routine(&ctx, task->ltt_arg);
 
-		ldap_pvt_thread_mutex_lock(&pool->ltp_mutex);
-		LDAP_SLIST_INSERT_HEAD(&pool->ltp_free_list, task, ltt_next.l);
+		ldap_pvt_thread_mutex_lock(&pq->ltp_mutex);
+		LDAP_SLIST_INSERT_HEAD(&pq->ltp_free_list, task, ltt_next.l);
 	}
  done:
 
@@ -702,13 +825,12 @@ ldap_int_thread_pool_wrapper (
 	thread_keys[keyslot].ctx = DELETED_THREAD_CTX;
 	ldap_pvt_thread_mutex_unlock(&ldap_pvt_thread_pool_mutex);
 
-	pool->ltp_open_count--;
-	SET_VARY_OPEN_COUNT(pool);
+	pq->ltp_open_count--;
 	/* let pool_destroy know we're all done */
-	if (pool->ltp_open_count == 0)
-		ldap_pvt_thread_cond_signal(&pool->ltp_cond);
+	if (pq->ltp_open_count == 0)
+		ldap_pvt_thread_cond_signal(&pq->ltp_cond);
 
-	ldap_pvt_thread_mutex_unlock(&pool->ltp_mutex);
+	ldap_pvt_thread_mutex_unlock(&pq->ltp_mutex);
 
 	ldap_pvt_thread_exit(NULL);
 	return(NULL);
@@ -728,6 +850,7 @@ static int
 handle_pause( ldap_pvt_thread_pool_t *tpool, int pause_type )
 {
 	struct ldap_int_thread_pool_s *pool;
+	struct ldap_int_thread_poolq_s *pq;
 	int ret = 0, pause, max_ltp_pause;
 
 	if (tpool == NULL)
@@ -741,6 +864,11 @@ handle_pause( ldap_pvt_thread_pool_t *tpool, int pause_type )
 	if (pause_type == CHECK_PAUSE && !pool->ltp_pause)
 		return(0);
 
+	{
+		ldap_int_thread_userctx_t *ctx = ldap_pvt_thread_pool_context();
+		pq = ctx->ltu_pq;
+	}
+
 	/* Let pool_unidle() ignore requests for new pauses */
 	max_ltp_pause = pause_type==PAUSE_ARG(GO_UNIDLE) ? WANT_PAUSE : NOT_PAUSED;
 
@@ -752,46 +880,74 @@ handle_pause( ldap_pvt_thread_pool_t *tpool, int pause_type )
 	pause_type -= pause;
 
 	if (pause_type & GO_IDLE) {
-		pool->ltp_pending_count++;
-		pool->ltp_active_count--;
-		if (pause && pool->ltp_active_count < 2) {
+		ldap_pvt_thread_mutex_unlock(&pool->ltp_mutex);
+		ldap_pvt_thread_mutex_lock(&pq->ltp_mutex);
+		pq->ltp_pending_count++;
+		pq->ltp_active_count--;
+		if (pause && pq->ltp_active_count < 1) {
 			/* Tell the task waiting to DO_PAUSE it can proceed */
-			ldap_pvt_thread_cond_signal(&pool->ltp_pcond);
+			ldap_pvt_thread_cond_signal(&pq->ltp_pcond);
 		}
+		ldap_pvt_thread_mutex_unlock(&pq->ltp_mutex);
 	}
 
 	if (pause_type & GO_UNIDLE) {
+		ldap_pvt_thread_mutex_unlock(&pool->ltp_mutex);
+		ldap_pvt_thread_mutex_lock(&pq->ltp_mutex);
 		/* Wait out pause if any, then cancel GO_IDLE */
 		if (pause > max_ltp_pause) {
 			ret = 1;
 			do {
-				ldap_pvt_thread_cond_wait(&pool->ltp_cond, &pool->ltp_mutex);
+				ldap_pvt_thread_cond_wait(&pq->ltp_cond, &pq->ltp_mutex);
 			} while (pool->ltp_pause > max_ltp_pause);
 		}
-		pool->ltp_pending_count--;
-		pool->ltp_active_count++;
+		pq->ltp_pending_count--;
+		pq->ltp_active_count++;
+		ldap_pvt_thread_mutex_unlock(&pq->ltp_mutex);
 	}
 
 	if (pause_type & DO_PAUSE) {
+		int i, j;
 		/* Tell everyone else to pause or finish, then await that */
 		ret = 0;
 		assert(!pool->ltp_pause);
 		pool->ltp_pause = WANT_PAUSE;
-		/* Let ldap_pvt_thread_pool_submit() through to its ltp_pause test,
-		 * and do not finish threads in ldap_pvt_thread_pool_wrapper() */
-		pool->ltp_open_count = -pool->ltp_open_count;
-		SET_VARY_OPEN_COUNT(pool);
-		/* Hide pending tasks from ldap_pvt_thread_pool_wrapper() */
-		pool->ltp_work_list = &empty_pending_list;
-		/* Wait for this task to become the sole active task */
-		while (pool->ltp_active_count > 1) {
-			ldap_pvt_thread_cond_wait(&pool->ltp_pcond, &pool->ltp_mutex);
-		}
+
+		for (i=0; i<pool->ltp_numqs; i++)
+			if (&pool->ltp_wqs[i] == pq) break;
+
+		ldap_pvt_thread_mutex_lock(&pq->ltp_mutex);
+		/* temporarily remove ourself from active count */
+		pq->ltp_active_count--;
+
+		j=i;
+		do {
+			if (j != i)
+				ldap_pvt_thread_mutex_lock(&pq->ltp_mutex);
+			/* Let ldap_pvt_thread_pool_submit() through to its ltp_pause test,
+			 * and do not finish threads in ldap_pvt_thread_pool_wrapper() */
+			pq->ltp_open_count = -pq->ltp_open_count;
+			/* Hide pending tasks from ldap_pvt_thread_pool_wrapper() */
+			pq->ltp_work_list = &empty_pending_list;
+			/* Wait for this task to become the sole active task */
+			while (pq->ltp_active_count > 0) {
+				ldap_pvt_thread_cond_wait(&pq->ltp_pcond, &pq->ltp_mutex);
+			}
+			ldap_pvt_thread_mutex_unlock(&pq->ltp_mutex);
+			if (pool->ltp_numqs > 1) {
+				j++;
+				j %= pool->ltp_numqs;
+			}
+		} while (j != i);
+
+		/* restore us to active count */
+		pool->ltp_wqs[i].ltp_active_count++;
+
 		assert(pool->ltp_pause == WANT_PAUSE);
 		pool->ltp_pause = PAUSED;
+		ldap_pvt_thread_mutex_unlock(&pool->ltp_mutex);
 	}
 
-	ldap_pvt_thread_mutex_unlock(&pool->ltp_mutex);
 	return(ret);
 }
 
@@ -837,6 +993,8 @@ ldap_pvt_thread_pool_resume (
 	ldap_pvt_thread_pool_t *tpool )
 {
 	struct ldap_int_thread_pool_s *pool;
+	struct ldap_int_thread_poolq_s *pq;
+	int i;
 
 	if (tpool == NULL)
 		return(-1);
@@ -850,12 +1008,16 @@ ldap_pvt_thread_pool_resume (
 
 	assert(pool->ltp_pause == PAUSED);
 	pool->ltp_pause = 0;
-	if (pool->ltp_open_count <= 0) /* true when paused, but be paranoid */
-		pool->ltp_open_count = -pool->ltp_open_count;
-	SET_VARY_OPEN_COUNT(pool);
-	pool->ltp_work_list = &pool->ltp_pending_list;
-
-	ldap_pvt_thread_cond_broadcast(&pool->ltp_cond);
+	for (i=0; i<pool->ltp_numqs; i++) {
+		pq = &pool->ltp_wqs[i];
+		ldap_pvt_thread_mutex_lock(&pq->ltp_mutex);
+		if (pq->ltp_open_count <= 0) /* true when paused, but be paranoid */
+			pq->ltp_open_count = -pq->ltp_open_count;
+		pq->ltp_work_list = &pq->ltp_pending_list;
+
+		ldap_pvt_thread_cond_broadcast(&pq->ltp_cond);
+		ldap_pvt_thread_mutex_unlock(&pq->ltp_mutex);
+	}
 
 	ldap_pvt_thread_mutex_unlock(&pool->ltp_mutex);
 	return(0);
--- openldap-2.4.36.2z/servers/slapd/bconfig.c.orig	2013-08-16 11:12:59.000000000 -0700
+++ openldap-2.4.36.2z/servers/slapd/bconfig.c	2013-08-19 15:24:50.780122373 -0700
@@ -194,6 +194,7 @@
 	CFG_ACL_ADD,
 	CFG_SYNC_SUBENTRY,
 	CFG_LTHREADS,
+	CFG_THREADQS,
 
 	CFG_LAST
 };
@@ -655,6 +656,14 @@
 #endif
 		"( OLcfgGlAt:66 NAME 'olcThreads' "
 			"SYNTAX OMsInteger SINGLE-VALUE )", NULL, NULL },
+	{ "threadqueues", "count", 2, 2, 0,
+#ifdef NO_THREADS
+		ARG_IGNORED, NULL,
+#else
+		ARG_INT|ARG_MAGIC|CFG_THREADQS, &config_generic,
+#endif
+		"( OLcfgGlAt:95 NAME 'olcThreadQueues' "
+			"SYNTAX OMsInteger SINGLE-VALUE )", NULL, NULL },
 	{ "timelimit", "limit", 2, 0, 0, ARG_MAY_DB|ARG_MAGIC,
 		&config_timelimit, "( OLcfgGlAt:67 NAME 'olcTimeLimit' "
 			"SYNTAX OMsDirectoryString )", NULL, NULL },
@@ -816,7 +825,8 @@
 		 "olcSecurity $ olcServerID $ olcSizeLimit $ "
 		 "olcSockbufMaxIncoming $ olcSockbufMaxIncomingAuth $ "
 		 "olcTCPBuffer $ "
-		 "olcThreads $ olcTimeLimit $ olcTLSCACertificateFile $ "
+		 "olcThreads $ olcThreadQueues $ "
+		 "olcTimeLimit $ olcTLSCACertificateFile $ "
 		 "olcTLSCACertificatePath $ olcTLSCertificateFile $ "
 		 "olcTLSCertificateKeyFile $ olcTLSCipherSuite $ olcTLSCRLCheck $ "
 		 "olcTLSRandFile $ olcTLSVerifyClient $ olcTLSDHParamFile $ "
@@ -917,6 +927,9 @@
 		case CFG_THREADS:
 			c->value_int = connection_pool_max;
 			break;
+		case CFG_THREADQS:
+			c->value_int = connection_pool_queues;
+			break;
 		case CFG_TTHREADS:
 			c->value_int = slap_tool_thread_max;
 			break;
@@ -1223,6 +1236,7 @@
 		/* single-valued attrs, no-ops */
 		case CFG_CONCUR:
 		case CFG_THREADS:
+		case CFG_THREADQS:
 		case CFG_TTHREADS:
 		case CFG_LTHREADS:
 		case CFG_RO:
@@ -1554,6 +1568,18 @@
 			connection_pool_max = c->value_int;	/* save for reference */
 			break;
 
+		case CFG_THREADQS:
+			if ( c->value_int < 1 ) {
+				snprintf( c->cr_msg, sizeof( c->cr_msg ),
+					"threadqueuess=%d smaller than minimum value 1",
+					c->value_int );
+				Debug(LDAP_DEBUG_ANY, "%s: %s.\n",
+					c->log, c->cr_msg, 0 );
+				return 1;
+			}
+			connection_pool_queues = c->value_int;	/* save for reference */
+			break;
+
 		case CFG_TTHREADS:
 			if ( slapMode & SLAP_TOOL_MODE )
 				ldap_pvt_thread_pool_maxthreads(&connection_pool, c->value_int);
diff --git a/servers/slapd/init.c b/servers/slapd/init.c
index f134903..26dacd7 100644
--- a/servers/slapd/init.c
+++ b/servers/slapd/init.c
@@ -59,7 +59,8 @@ BerVarray default_referral = NULL;
  * global variables that need mutex protection
  */
 ldap_pvt_thread_pool_t	connection_pool;
-int			connection_pool_max = SLAP_MAX_WORKER_THREADS;
+int		connection_pool_max = SLAP_MAX_WORKER_THREADS;
+int		connection_pool_queues = 1;
 int		slap_tool_thread_max = 1;
 
 slap_counters_t			slap_counters, *slap_counters_list;
@@ -135,8 +136,8 @@ slap_init( int mode, const char *name )
 
 		slap_name = name;
 
-		ldap_pvt_thread_pool_init( &connection_pool,
-				connection_pool_max, 0);
+		ldap_pvt_thread_pool_init_q( &connection_pool,
+				connection_pool_max, 0, 4);
 
 		slap_counters_init( &slap_counters );
 
diff --git a/servers/slapd/proto-slap.h b/servers/slapd/proto-slap.h
index a6a47f0..31c73da 100644
--- a/servers/slapd/proto-slap.h
+++ b/servers/slapd/proto-slap.h
@@ -2066,6 +2066,7 @@ LDAP_SLAPD_V (time_t)		starttime;
 
 LDAP_SLAPD_V (ldap_pvt_thread_pool_t)	connection_pool;
 LDAP_SLAPD_V (int)			connection_pool_max;
+LDAP_SLAPD_V (int)			connection_pool_queues;
 LDAP_SLAPD_V (int)			slap_tool_thread_max;
 
 LDAP_SLAPD_V (ldap_pvt_thread_mutex_t)	entry2str_mutex;
-- 
1.7.4.2

From f947f789f373ee807a5bf5af0b17050df34ecb22 Mon Sep 17 00:00:00 2001
From: Howard Chu <hyc@openldap.org>
Date: Sun, 18 Aug 2013 21:15:30 -0700
Subject: [PATCH] Fix prev commit

Hardcoded number of queues was leftover from preliminary
work. Use connection_pool_queues.
---
 servers/slapd/init.c |    2 +-
 1 files changed, 1 insertions(+), 1 deletions(-)

diff --git a/servers/slapd/init.c b/servers/slapd/init.c
index 26dacd7..79271d0 100644
--- a/servers/slapd/init.c
+++ b/servers/slapd/init.c
@@ -137,7 +137,7 @@ slap_init( int mode, const char *name )
 		slap_name = name;
 
 		ldap_pvt_thread_pool_init_q( &connection_pool,
-				connection_pool_max, 0, 4);
+				connection_pool_max, 0, connection_pool_queues);
 
 		slap_counters_init( &slap_counters );
 
-- 
1.7.4.2

From eaa3469736b5031e75df8b74d38bf94797c4f96a Mon Sep 17 00:00:00 2001
From: Howard Chu <hyc@openldap.org>
Date: Mon, 19 Aug 2013 04:20:35 -0700
Subject: [PATCH] Fix 34f832faee9f215dfdb61de52506f2905258b147

Lock ordering issues
---
 libraries/libldap_r/tpool.c |   81 +++++++++++++++++++++++++++++++++----------
 1 files changed, 62 insertions(+), 19 deletions(-)

diff --git a/libraries/libldap_r/tpool.c b/libraries/libldap_r/tpool.c
index 23a0624..1717846 100644
--- a/libraries/libldap_r/tpool.c
+++ b/libraries/libldap_r/tpool.c
@@ -101,8 +101,10 @@ struct ldap_int_thread_poolq_s {
 	/* not paused and something to do for pool_<wrapper/pause/destroy>() */
 	ldap_pvt_thread_cond_t ltp_cond;
 
-	/* ltp_active_count <= 1 && ltp_pause */
-	ldap_pvt_thread_cond_t ltp_pcond;
+	/* Some active task needs to be the sole active task.
+	 * Atomic variable so ldap_pvt_thread_pool_pausing() can read it.
+	 */
+	volatile sig_atomic_t ltp_pause;
 
 	/* ltp_pause == 0 ? &ltp_pending_list : &empty_pending_list,
 	 * maintaned to reduce work for pool_wrapper()
@@ -136,6 +138,12 @@ struct ldap_int_thread_pool_s {
 	/* protect members below, and protect thread_keys[] during pauses */
 	ldap_pvt_thread_mutex_t ltp_mutex;
 
+	/* ltp_active_count <= 1 && ltp_pause */
+	ldap_pvt_thread_cond_t ltp_pcond;
+
+	/* number of active queues */
+	int ltp_active_queues;
+
 	/* The pool is finishing, waiting for its threads to close.
 	 * They close when ltp_pending_list is done.  pool_submit()
 	 * rejects new tasks.  ltp_max_pending = -(its old value).
@@ -233,6 +241,10 @@ ldap_pvt_thread_pool_init_q (
 	if (rc != 0)
 		return(rc);
 
+	rc = ldap_pvt_thread_cond_init(&pool->ltp_pcond);
+	if (rc != 0)
+		return(rc);
+
 	rem_thr = max_threads % numqs;
 	rem_pend = max_pending % numqs;
 	for ( i=0; i<numqs; i++ ) {
@@ -244,9 +256,6 @@ ldap_pvt_thread_pool_init_q (
 		rc = ldap_pvt_thread_cond_init(&pq->ltp_cond);
 		if (rc != 0)
 			return(rc);
-		rc = ldap_pvt_thread_cond_init(&pq->ltp_pcond);
-		if (rc != 0)
-			return(rc);
 		LDAP_STAILQ_INIT(&pq->ltp_pending_list);
 		pq->ltp_work_list = &pq->ltp_pending_list;
 		LDAP_SLIST_INIT(&pq->ltp_free_list);
@@ -684,6 +693,8 @@ ldap_pvt_thread_pool_destroy ( ldap_pvt_thread_pool_t *tpool, int run_pending )
 	if (pool->ltp_max_pending > 0)
 		pool->ltp_max_pending = -pool->ltp_max_pending;
 
+	ldap_pvt_thread_mutex_unlock(&pool->ltp_mutex);
+
 	for (i=0; i<pool->ltp_numqs; i++) {
 		pq = &pool->ltp_wqs[i];
 		ldap_pvt_thread_mutex_lock(&pq->ltp_mutex);
@@ -709,12 +720,11 @@ ldap_pvt_thread_pool_destroy ( ldap_pvt_thread_pool_t *tpool, int run_pending )
 			LDAP_FREE(task);
 		}
 		ldap_pvt_thread_mutex_unlock(&pq->ltp_mutex);
-		ldap_pvt_thread_cond_destroy(&pq->ltp_pcond);
 		ldap_pvt_thread_cond_destroy(&pq->ltp_cond);
 		ldap_pvt_thread_mutex_destroy(&pq->ltp_mutex);
 	}
 
-	ldap_pvt_thread_mutex_unlock(&pool->ltp_mutex);
+	ldap_pvt_thread_cond_destroy(&pool->ltp_pcond);
 	ldap_pvt_thread_mutex_destroy(&pool->ltp_mutex);
 	LDAP_FREE(pool);
 	*tpool = NULL;
@@ -770,9 +780,15 @@ ldap_int_thread_pool_wrapper (
 		work_list = pq->ltp_work_list; /* help the compiler a bit */
 		task = LDAP_STAILQ_FIRST(work_list);
 		if (task == NULL) {	/* paused or no pending tasks */
-			if (--(pq->ltp_active_count) < 2) {
-				/* Notify pool_pause it is the sole active thread. */
-				ldap_pvt_thread_cond_signal(&pq->ltp_pcond);
+			if (--(pq->ltp_active_count) < 1) {
+				ldap_pvt_thread_mutex_unlock(&pq->ltp_mutex);
+				ldap_pvt_thread_mutex_lock(&pool->ltp_mutex);
+				if (--(pool->ltp_active_queues) < 1) {
+					/* Notify pool_pause it is the sole active thread. */
+					ldap_pvt_thread_cond_signal(&pool->ltp_pcond);
+				}
+				ldap_pvt_thread_mutex_unlock(&pool->ltp_mutex);
+				ldap_pvt_thread_mutex_lock(&pq->ltp_mutex);
 			}
 
 			do {
@@ -879,31 +895,46 @@ handle_pause( ldap_pvt_thread_pool_t *tpool, int pause_type )
 	/* If ltp_pause and not GO_IDLE|GO_UNIDLE: Set GO_IDLE,GO_UNIDLE */
 	pause_type -= pause;
 
-	if (pause_type & GO_IDLE) {
+	if (!(pause_type & DO_PAUSE))
 		ldap_pvt_thread_mutex_unlock(&pool->ltp_mutex);
+
+	if (pause_type & GO_IDLE) {
+		int do_pool = 0;
 		ldap_pvt_thread_mutex_lock(&pq->ltp_mutex);
 		pq->ltp_pending_count++;
 		pq->ltp_active_count--;
 		if (pause && pq->ltp_active_count < 1) {
-			/* Tell the task waiting to DO_PAUSE it can proceed */
-			ldap_pvt_thread_cond_signal(&pq->ltp_pcond);
+			do_pool = 1;
 		}
 		ldap_pvt_thread_mutex_unlock(&pq->ltp_mutex);
+		if (do_pool) {
+			if (!(pause_type & DO_PAUSE))
+				ldap_pvt_thread_mutex_lock(&pool->ltp_mutex);
+			pool->ltp_active_queues--;
+			if (pool->ltp_active_queues < 1)
+			/* Tell the task waiting to DO_PAUSE it can proceed */
+				ldap_pvt_thread_cond_signal(&pool->ltp_pcond);
+			if (!(pause_type & DO_PAUSE))
+				ldap_pvt_thread_mutex_unlock(&pool->ltp_mutex);
+		}
 	}
 
 	if (pause_type & GO_UNIDLE) {
-		ldap_pvt_thread_mutex_unlock(&pool->ltp_mutex);
+		if (pause_type & DO_PAUSE)
+			ldap_pvt_thread_mutex_unlock(&pool->ltp_mutex);
 		ldap_pvt_thread_mutex_lock(&pq->ltp_mutex);
 		/* Wait out pause if any, then cancel GO_IDLE */
 		if (pause > max_ltp_pause) {
 			ret = 1;
 			do {
 				ldap_pvt_thread_cond_wait(&pq->ltp_cond, &pq->ltp_mutex);
-			} while (pool->ltp_pause > max_ltp_pause);
+			} while (pq->ltp_pause > max_ltp_pause);
 		}
 		pq->ltp_pending_count--;
 		pq->ltp_active_count++;
 		ldap_pvt_thread_mutex_unlock(&pq->ltp_mutex);
+		if (pause_type & DO_PAUSE)
+			ldap_pvt_thread_mutex_lock(&pool->ltp_mutex);
 	}
 
 	if (pause_type & DO_PAUSE) {
@@ -912,6 +943,7 @@ handle_pause( ldap_pvt_thread_pool_t *tpool, int pause_type )
 		ret = 0;
 		assert(!pool->ltp_pause);
 		pool->ltp_pause = WANT_PAUSE;
+		pool->ltp_active_queues = 0;
 
 		for (i=0; i<pool->ltp_numqs; i++)
 			if (&pool->ltp_wqs[i] == pq) break;
@@ -922,17 +954,21 @@ handle_pause( ldap_pvt_thread_pool_t *tpool, int pause_type )
 
 		j=i;
 		do {
+			pq = &pool->ltp_wqs[j];
 			if (j != i)
 				ldap_pvt_thread_mutex_lock(&pq->ltp_mutex);
+
+			pq->ltp_pause = WANT_PAUSE;
+
 			/* Let ldap_pvt_thread_pool_submit() through to its ltp_pause test,
 			 * and do not finish threads in ldap_pvt_thread_pool_wrapper() */
 			pq->ltp_open_count = -pq->ltp_open_count;
 			/* Hide pending tasks from ldap_pvt_thread_pool_wrapper() */
 			pq->ltp_work_list = &empty_pending_list;
-			/* Wait for this task to become the sole active task */
-			while (pq->ltp_active_count > 0) {
-				ldap_pvt_thread_cond_wait(&pq->ltp_pcond, &pq->ltp_mutex);
-			}
+
+			if (pq->ltp_active_count > 0)
+				pool->ltp_active_queues++;
+
 			ldap_pvt_thread_mutex_unlock(&pq->ltp_mutex);
 			if (pool->ltp_numqs > 1) {
 				j++;
@@ -940,11 +976,17 @@ handle_pause( ldap_pvt_thread_pool_t *tpool, int pause_type )
 			}
 		} while (j != i);
 
+		/* Wait for this task to become the sole active task */
+		while (pool->ltp_active_queues > 0)
+			ldap_pvt_thread_cond_wait(&pool->ltp_pcond, &pool->ltp_mutex);
+
 		/* restore us to active count */
 		pool->ltp_wqs[i].ltp_active_count++;
 
 		assert(pool->ltp_pause == WANT_PAUSE);
 		pool->ltp_pause = PAUSED;
+		for (i=0; i<pool->ltp_numqs; i++)
+			pool->ltp_wqs[i].ltp_pause = PAUSED;
 		ldap_pvt_thread_mutex_unlock(&pool->ltp_mutex);
 	}
 
@@ -1015,6 +1057,7 @@ ldap_pvt_thread_pool_resume (
 			pq->ltp_open_count = -pq->ltp_open_count;
 		pq->ltp_work_list = &pq->ltp_pending_list;
 
+		pq->ltp_pause = 0;
 		ldap_pvt_thread_cond_broadcast(&pq->ltp_cond);
 		ldap_pvt_thread_mutex_unlock(&pq->ltp_mutex);
 	}
-- 
1.7.4.2

From 0c86184bae43a67fd9be2460d83b3cfd320fd7c3 Mon Sep 17 00:00:00 2001
From: Howard Chu <hyc@openldap.org>
Date: Mon, 19 Aug 2013 13:54:17 -0700
Subject: [PATCH] More fixes for prev commit

---
 libraries/libldap_r/tpool.c |  111 ++++++++++++++++++++++--------------------
 1 files changed, 58 insertions(+), 53 deletions(-)

diff --git a/libraries/libldap_r/tpool.c b/libraries/libldap_r/tpool.c
index 1717846..d9f575d 100644
--- a/libraries/libldap_r/tpool.c
+++ b/libraries/libldap_r/tpool.c
@@ -64,7 +64,7 @@ typedef struct ldap_int_thread_userctx_s {
 /* Simple {thread ID -> context} hash table; key=ctx->ltu_id.
  * Protected by ldap_pvt_thread_pool_mutex except during pauses,
  * when it is read-only (used by pool_purgekey and pool_context).
- * Protected by tpool->ltp_mutex during pauses.
+ * Protected by ldap_pvt_thread_pool_mutex.
  */
 static struct {
 	ldap_int_thread_userctx_t *ctx;
@@ -101,11 +101,6 @@ struct ldap_int_thread_poolq_s {
 	/* not paused and something to do for pool_<wrapper/pause/destroy>() */
 	ldap_pvt_thread_cond_t ltp_cond;
 
-	/* Some active task needs to be the sole active task.
-	 * Atomic variable so ldap_pvt_thread_pool_pausing() can read it.
-	 */
-	volatile sig_atomic_t ltp_pause;
-
 	/* ltp_pause == 0 ? &ltp_pending_list : &empty_pending_list,
 	 * maintaned to reduce work for pool_wrapper()
 	 */
@@ -138,6 +133,9 @@ struct ldap_int_thread_pool_s {
 	/* protect members below, and protect thread_keys[] during pauses */
 	ldap_pvt_thread_mutex_t ltp_mutex;
 
+	/* not paused and something to do for pool_<wrapper/pause/destroy>() */
+	ldap_pvt_thread_cond_t ltp_cond;
+
 	/* ltp_active_count <= 1 && ltp_pause */
 	ldap_pvt_thread_cond_t ltp_pcond;
 
@@ -241,6 +239,10 @@ ldap_pvt_thread_pool_init_q (
 	if (rc != 0)
 		return(rc);
 
+	rc = ldap_pvt_thread_cond_init(&pool->ltp_cond);
+	if (rc != 0)
+		return(rc);
+
 	rc = ldap_pvt_thread_cond_init(&pool->ltp_pcond);
 	if (rc != 0)
 		return(rc);
@@ -369,13 +371,13 @@ ldap_pvt_thread_pool_submit (
 	pq->ltp_pending_count++;
 	LDAP_STAILQ_INSERT_TAIL(&pq->ltp_pending_list, task, ltt_next.q);
 
+	if (pool->ltp_pause)
+		goto done;
+
 	/* should we open (create) a thread? */
 	if (pq->ltp_open_count < pq->ltp_active_count+pq->ltp_pending_count &&
 		pq->ltp_open_count < pq->ltp_max_count)
 	{
-		if (pool->ltp_pause)
-			goto done;
-
 		pq->ltp_starting++;
 		pq->ltp_open_count++;
 
@@ -693,6 +695,7 @@ ldap_pvt_thread_pool_destroy ( ldap_pvt_thread_pool_t *tpool, int run_pending )
 	if (pool->ltp_max_pending > 0)
 		pool->ltp_max_pending = -pool->ltp_max_pending;
 
+	ldap_pvt_thread_cond_broadcast(&pool->ltp_cond);
 	ldap_pvt_thread_mutex_unlock(&pool->ltp_mutex);
 
 	for (i=0; i<pool->ltp_numqs; i++) {
@@ -709,8 +712,7 @@ ldap_pvt_thread_pool_destroy ( ldap_pvt_thread_pool_t *tpool, int run_pending )
 		}
 
 		while (pq->ltp_open_count) {
-			if (!pool->ltp_pause)
-				ldap_pvt_thread_cond_broadcast(&pq->ltp_cond);
+			ldap_pvt_thread_cond_broadcast(&pq->ltp_cond);
 			ldap_pvt_thread_cond_wait(&pq->ltp_cond, &pq->ltp_mutex);
 		}
 
@@ -725,6 +727,7 @@ ldap_pvt_thread_pool_destroy ( ldap_pvt_thread_pool_t *tpool, int run_pending )
 	}
 
 	ldap_pvt_thread_cond_destroy(&pool->ltp_pcond);
+	ldap_pvt_thread_cond_destroy(&pool->ltp_cond);
 	ldap_pvt_thread_mutex_destroy(&pool->ltp_mutex);
 	LDAP_FREE(pool);
 	*tpool = NULL;
@@ -743,6 +746,7 @@ ldap_int_thread_pool_wrapper (
 	ldap_int_tpool_plist_t *work_list;
 	ldap_int_thread_userctx_t ctx, *kctx;
 	unsigned i, keyslot, hash;
+	int global_lock = 0;
 
 	assert(pool != NULL);
 
@@ -756,11 +760,13 @@ ldap_int_thread_pool_wrapper (
 
 	ldap_pvt_thread_key_setdata( ldap_tpool_key, &ctx );
 
-	ldap_pvt_thread_mutex_lock(&pq->ltp_mutex);
-
-	/* thread_keys[] is read-only when paused */
-	while (pool->ltp_pause)
-		ldap_pvt_thread_cond_wait(&pq->ltp_cond, &pq->ltp_mutex);
+	if (pool->ltp_pause) {
+		ldap_pvt_thread_mutex_lock(&pool->ltp_mutex);
+		/* thread_keys[] is read-only when paused */
+		while (pool->ltp_pause)
+			ldap_pvt_thread_cond_wait(&pool->ltp_cond, &pool->ltp_mutex);
+		ldap_pvt_thread_mutex_unlock(&pool->ltp_mutex);
+	}
 
 	/* find a key slot to give this thread ID and store a
 	 * pointer to our keys there; start at the thread ID
@@ -773,6 +779,7 @@ ldap_int_thread_pool_wrapper (
 	thread_keys[keyslot].ctx = &ctx;
 	ldap_pvt_thread_mutex_unlock(&ldap_pvt_thread_pool_mutex);
 
+	ldap_pvt_thread_mutex_lock(&pq->ltp_mutex);
 	pq->ltp_starting--;
 	pq->ltp_active_count++;
 
@@ -781,14 +788,15 @@ ldap_int_thread_pool_wrapper (
 		task = LDAP_STAILQ_FIRST(work_list);
 		if (task == NULL) {	/* paused or no pending tasks */
 			if (--(pq->ltp_active_count) < 1) {
-				ldap_pvt_thread_mutex_unlock(&pq->ltp_mutex);
-				ldap_pvt_thread_mutex_lock(&pool->ltp_mutex);
-				if (--(pool->ltp_active_queues) < 1) {
-					/* Notify pool_pause it is the sole active thread. */
-					ldap_pvt_thread_cond_signal(&pool->ltp_pcond);
+				if (pool->ltp_pause) {
+					ldap_pvt_thread_mutex_unlock(&pq->ltp_mutex);
+					ldap_pvt_thread_mutex_lock(&pool->ltp_mutex);
+					global_lock = 1;
+					if (--(pool->ltp_active_queues) < 1) {
+						/* Notify pool_pause it is the sole active thread. */
+						ldap_pvt_thread_cond_signal(&pool->ltp_pcond);
+					}
 				}
-				ldap_pvt_thread_mutex_unlock(&pool->ltp_mutex);
-				ldap_pvt_thread_mutex_lock(&pq->ltp_mutex);
 			}
 
 			do {
@@ -811,12 +819,25 @@ ldap_int_thread_pool_wrapper (
 				 * Just use pthread_cond_timedwait() if we want to
 				 * check idle time.
 				 */
-				ldap_pvt_thread_cond_wait(&pq->ltp_cond, &pq->ltp_mutex);
+				if (global_lock) {
+					ldap_pvt_thread_cond_wait(&pool->ltp_cond, &pool->ltp_mutex);
+					if (!pool->ltp_pause) {
+						ldap_pvt_thread_mutex_unlock(&pool->ltp_mutex);
+						ldap_pvt_thread_mutex_lock(&pq->ltp_mutex);
+						global_lock = 0;
+					}
+				} else
+					ldap_pvt_thread_cond_wait(&pq->ltp_cond, &pq->ltp_mutex);
 
 				work_list = pq->ltp_work_list;
 				task = LDAP_STAILQ_FIRST(work_list);
 			} while (task == NULL);
 
+			if (global_lock) {
+				ldap_pvt_thread_mutex_unlock(&pool->ltp_mutex);
+				ldap_pvt_thread_mutex_lock(&pq->ltp_mutex);
+				global_lock = 0;
+			}
 			pq->ltp_active_count++;
 		}
 
@@ -831,13 +852,12 @@ ldap_int_thread_pool_wrapper (
 	}
  done:
 
-	assert(!pool->ltp_pause); /* thread_keys writable, ltp_open_count >= 0 */
+	ldap_pvt_thread_mutex_lock(&ldap_pvt_thread_pool_mutex);
 
-	/* The ltp_mutex lock protects ctx->ltu_key from pool_purgekey()
+	/* The pool_mutex lock protects ctx->ltu_key from pool_purgekey()
 	 * during this call, since it prevents new pauses. */
 	ldap_pvt_thread_pool_context_reset(&ctx);
 
-	ldap_pvt_thread_mutex_lock(&ldap_pvt_thread_pool_mutex);
 	thread_keys[keyslot].ctx = DELETED_THREAD_CTX;
 	ldap_pvt_thread_mutex_unlock(&ldap_pvt_thread_pool_mutex);
 
@@ -846,7 +866,10 @@ ldap_int_thread_pool_wrapper (
 	if (pq->ltp_open_count == 0)
 		ldap_pvt_thread_cond_signal(&pq->ltp_cond);
 
-	ldap_pvt_thread_mutex_unlock(&pq->ltp_mutex);
+	if (global_lock)
+		ldap_pvt_thread_mutex_unlock(&pool->ltp_mutex);
+	else
+		ldap_pvt_thread_mutex_unlock(&pq->ltp_mutex);
 
 	ldap_pvt_thread_exit(NULL);
 	return(NULL);
@@ -895,9 +918,6 @@ handle_pause( ldap_pvt_thread_pool_t *tpool, int pause_type )
 	/* If ltp_pause and not GO_IDLE|GO_UNIDLE: Set GO_IDLE,GO_UNIDLE */
 	pause_type -= pause;
 
-	if (!(pause_type & DO_PAUSE))
-		ldap_pvt_thread_mutex_unlock(&pool->ltp_mutex);
-
 	if (pause_type & GO_IDLE) {
 		int do_pool = 0;
 		ldap_pvt_thread_mutex_lock(&pq->ltp_mutex);
@@ -908,33 +928,25 @@ handle_pause( ldap_pvt_thread_pool_t *tpool, int pause_type )
 		}
 		ldap_pvt_thread_mutex_unlock(&pq->ltp_mutex);
 		if (do_pool) {
-			if (!(pause_type & DO_PAUSE))
-				ldap_pvt_thread_mutex_lock(&pool->ltp_mutex);
 			pool->ltp_active_queues--;
 			if (pool->ltp_active_queues < 1)
 			/* Tell the task waiting to DO_PAUSE it can proceed */
 				ldap_pvt_thread_cond_signal(&pool->ltp_pcond);
-			if (!(pause_type & DO_PAUSE))
-				ldap_pvt_thread_mutex_unlock(&pool->ltp_mutex);
 		}
 	}
 
 	if (pause_type & GO_UNIDLE) {
-		if (pause_type & DO_PAUSE)
-			ldap_pvt_thread_mutex_unlock(&pool->ltp_mutex);
-		ldap_pvt_thread_mutex_lock(&pq->ltp_mutex);
 		/* Wait out pause if any, then cancel GO_IDLE */
 		if (pause > max_ltp_pause) {
 			ret = 1;
 			do {
-				ldap_pvt_thread_cond_wait(&pq->ltp_cond, &pq->ltp_mutex);
-			} while (pq->ltp_pause > max_ltp_pause);
+				ldap_pvt_thread_cond_wait(&pool->ltp_cond, &pool->ltp_mutex);
+			} while (pool->ltp_pause > max_ltp_pause);
 		}
+		ldap_pvt_thread_mutex_lock(&pq->ltp_mutex);
 		pq->ltp_pending_count--;
 		pq->ltp_active_count++;
 		ldap_pvt_thread_mutex_unlock(&pq->ltp_mutex);
-		if (pause_type & DO_PAUSE)
-			ldap_pvt_thread_mutex_lock(&pool->ltp_mutex);
 	}
 
 	if (pause_type & DO_PAUSE) {
@@ -958,8 +970,6 @@ handle_pause( ldap_pvt_thread_pool_t *tpool, int pause_type )
 			if (j != i)
 				ldap_pvt_thread_mutex_lock(&pq->ltp_mutex);
 
-			pq->ltp_pause = WANT_PAUSE;
-
 			/* Let ldap_pvt_thread_pool_submit() through to its ltp_pause test,
 			 * and do not finish threads in ldap_pvt_thread_pool_wrapper() */
 			pq->ltp_open_count = -pq->ltp_open_count;
@@ -985,10 +995,8 @@ handle_pause( ldap_pvt_thread_pool_t *tpool, int pause_type )
 
 		assert(pool->ltp_pause == WANT_PAUSE);
 		pool->ltp_pause = PAUSED;
-		for (i=0; i<pool->ltp_numqs; i++)
-			pool->ltp_wqs[i].ltp_pause = PAUSED;
-		ldap_pvt_thread_mutex_unlock(&pool->ltp_mutex);
 	}
+	ldap_pvt_thread_mutex_unlock(&pool->ltp_mutex);
 
 	return(ret);
 }
@@ -1047,21 +1055,16 @@ ldap_pvt_thread_pool_resume (
 		return(0);
 
 	ldap_pvt_thread_mutex_lock(&pool->ltp_mutex);
-
 	assert(pool->ltp_pause == PAUSED);
 	pool->ltp_pause = 0;
 	for (i=0; i<pool->ltp_numqs; i++) {
 		pq = &pool->ltp_wqs[i];
-		ldap_pvt_thread_mutex_lock(&pq->ltp_mutex);
 		if (pq->ltp_open_count <= 0) /* true when paused, but be paranoid */
 			pq->ltp_open_count = -pq->ltp_open_count;
 		pq->ltp_work_list = &pq->ltp_pending_list;
-
-		pq->ltp_pause = 0;
 		ldap_pvt_thread_cond_broadcast(&pq->ltp_cond);
-		ldap_pvt_thread_mutex_unlock(&pq->ltp_mutex);
 	}
-
+	ldap_pvt_thread_cond_broadcast(&pool->ltp_cond);
 	ldap_pvt_thread_mutex_unlock(&pool->ltp_mutex);
 	return(0);
 }
@@ -1168,6 +1171,7 @@ void ldap_pvt_thread_pool_purgekey( void *key )
 
 	assert ( key != NULL );
 
+	ldap_pvt_thread_mutex_lock(&ldap_pvt_thread_pool_mutex);
 	for ( i=0; i<LDAP_MAXTHR; i++ ) {
 		ctx = thread_keys[i].ctx;
 		if ( ctx && ctx != DELETED_THREAD_CTX ) {
@@ -1182,6 +1186,7 @@ void ldap_pvt_thread_pool_purgekey( void *key )
 			}
 		}
 	}
+	ldap_pvt_thread_mutex_unlock(&ldap_pvt_thread_pool_mutex);
 }
 
 /*
-- 
1.7.4.2

From 50ab5bb1ed1c9fc23a70d1c38e726937f1147add Mon Sep 17 00:00:00 2001
From: Howard Chu <hyc@openldap.org>
Date: Mon, 19 Aug 2013 14:24:00 -0700
Subject: [PATCH] Cleanup comments in prev commit

---
 libraries/libldap_r/tpool.c |   33 ++++++++++++++++++++-------------
 1 files changed, 20 insertions(+), 13 deletions(-)

diff --git a/libraries/libldap_r/tpool.c b/libraries/libldap_r/tpool.c
index d9f575d..eaea58e 100644
--- a/libraries/libldap_r/tpool.c
+++ b/libraries/libldap_r/tpool.c
@@ -95,10 +95,14 @@ typedef LDAP_STAILQ_HEAD(tcq, ldap_int_thread_task_s) ldap_int_tpool_plist_t;
 struct ldap_int_thread_poolq_s {
 	struct ldap_int_thread_pool_s *ltp_pool;
 
-	/* protect members below, and protect thread_keys[] during pauses */
+	/* protect members below */
 	ldap_pvt_thread_mutex_t ltp_mutex;
 
-	/* not paused and something to do for pool_<wrapper/pause/destroy>() */
+	/* not paused and something to do for pool_<wrapper/pause/destroy>()
+	 * Used for normal pool operation, to synch between submitter and
+	 * worker threads. Not used for pauses. In normal operation multiple
+	 * queues can rendezvous without acquiring the main pool lock.
+	 */
 	ldap_pvt_thread_cond_t ltp_cond;
 
 	/* ltp_pause == 0 ? &ltp_pending_list : &empty_pending_list,
@@ -110,7 +114,7 @@ struct ldap_int_thread_poolq_s {
 	ldap_int_tpool_plist_t ltp_pending_list;
 	LDAP_SLIST_HEAD(tcl, ldap_int_thread_task_s) ltp_free_list;
 
-	/* Max number of threads in pool, or 0 for default (LDAP_MAXTHR) */
+	/* Max number of threads in this queue */
 	int ltp_max_count;
 
 	/* Max pending + paused + idle tasks, negated when ltp_finishing */
@@ -130,13 +134,16 @@ struct ldap_int_thread_pool_s {
 	/* number of poolqs */
 	int ltp_numqs;
 
-	/* protect members below, and protect thread_keys[] during pauses */
+	/* protect members below */
 	ldap_pvt_thread_mutex_t ltp_mutex;
 
-	/* not paused and something to do for pool_<wrapper/pause/destroy>() */
+	/* paused and waiting for resume
+	 * When a pause is in effect all workers switch to waiting on
+	 * this cond instead of their per-queue cond.
+	 */
 	ldap_pvt_thread_cond_t ltp_cond;
 
-	/* ltp_active_count <= 1 && ltp_pause */
+	/* ltp_active_queues < 1 && ltp_pause */
 	ldap_pvt_thread_cond_t ltp_pcond;
 
 	/* number of active queues */
@@ -746,7 +753,7 @@ ldap_int_thread_pool_wrapper (
 	ldap_int_tpool_plist_t *work_list;
 	ldap_int_thread_userctx_t ctx, *kctx;
 	unsigned i, keyslot, hash;
-	int global_lock = 0;
+	int pool_lock = 0;
 
 	assert(pool != NULL);
 
@@ -791,7 +798,7 @@ ldap_int_thread_pool_wrapper (
 				if (pool->ltp_pause) {
 					ldap_pvt_thread_mutex_unlock(&pq->ltp_mutex);
 					ldap_pvt_thread_mutex_lock(&pool->ltp_mutex);
-					global_lock = 1;
+					pool_lock = 1;
 					if (--(pool->ltp_active_queues) < 1) {
 						/* Notify pool_pause it is the sole active thread. */
 						ldap_pvt_thread_cond_signal(&pool->ltp_pcond);
@@ -819,12 +826,12 @@ ldap_int_thread_pool_wrapper (
 				 * Just use pthread_cond_timedwait() if we want to
 				 * check idle time.
 				 */
-				if (global_lock) {
+				if (pool_lock) {
 					ldap_pvt_thread_cond_wait(&pool->ltp_cond, &pool->ltp_mutex);
 					if (!pool->ltp_pause) {
 						ldap_pvt_thread_mutex_unlock(&pool->ltp_mutex);
 						ldap_pvt_thread_mutex_lock(&pq->ltp_mutex);
-						global_lock = 0;
+						pool_lock = 0;
 					}
 				} else
 					ldap_pvt_thread_cond_wait(&pq->ltp_cond, &pq->ltp_mutex);
@@ -833,10 +840,10 @@ ldap_int_thread_pool_wrapper (
 				task = LDAP_STAILQ_FIRST(work_list);
 			} while (task == NULL);
 
-			if (global_lock) {
+			if (pool_lock) {
 				ldap_pvt_thread_mutex_unlock(&pool->ltp_mutex);
 				ldap_pvt_thread_mutex_lock(&pq->ltp_mutex);
-				global_lock = 0;
+				pool_lock = 0;
 			}
 			pq->ltp_active_count++;
 		}
@@ -866,7 +873,7 @@ ldap_int_thread_pool_wrapper (
 	if (pq->ltp_open_count == 0)
 		ldap_pvt_thread_cond_signal(&pq->ltp_cond);
 
-	if (global_lock)
+	if (pool_lock)
 		ldap_pvt_thread_mutex_unlock(&pool->ltp_mutex);
 	else
 		ldap_pvt_thread_mutex_unlock(&pq->ltp_mutex);
-- 
1.7.4.2

From 0ef9e6107baf45d29e194442991132df6c190adb Mon Sep 17 00:00:00 2001
From: Howard Chu <hyc@openldap.org>
Date: Tue, 3 Sep 2013 15:06:37 -0700
Subject: [PATCH] More for threadpool queues

Allow dynamic reconfig
---
 libraries/libldap_r/tpool.c |  147 ++++++++++++++++++++++++++++++++++++-------
 servers/slapd/bconfig.c     |    2 +
 2 files changed, 125 insertions(+), 24 deletions(-)

diff --git a/libraries/libldap_r/tpool.c b/libraries/libldap_r/tpool.c
index eaea58e..87fc0b3 100644
--- a/libraries/libldap_r/tpool.c
+++ b/libraries/libldap_r/tpool.c
@@ -32,6 +32,10 @@
 
 #ifndef LDAP_THREAD_HAVE_TPOOL
 
+#ifndef CACHELINE
+#define CACHELINE	64
+#endif
+
 /* Thread-specific key with data and optional free function */
 typedef struct ldap_int_tpool_key_s {
 	void *ltk_key;
@@ -93,6 +97,8 @@ typedef struct ldap_int_thread_task_s {
 typedef LDAP_STAILQ_HEAD(tcq, ldap_int_thread_task_s) ldap_int_tpool_plist_t;
 
 struct ldap_int_thread_poolq_s {
+	void *ltp_free;
+
 	struct ldap_int_thread_pool_s *ltp_pool;
 
 	/* protect members below */
@@ -129,7 +135,7 @@ struct ldap_int_thread_poolq_s {
 struct ldap_int_thread_pool_s {
 	LDAP_STAILQ_ENTRY(ldap_int_thread_pool_s) ltp_next;
 
-	struct ldap_int_thread_poolq_s *ltp_wqs;
+	struct ldap_int_thread_poolq_s **ltp_wqs;
 
 	/* number of poolqs */
 	int ltp_numqs;
@@ -231,12 +237,29 @@ ldap_pvt_thread_pool_init_q (
 
 	*tpool = NULL;
 	pool = (ldap_pvt_thread_pool_t) LDAP_CALLOC(1,
-		sizeof(struct ldap_int_thread_pool_s) +
-		numqs * sizeof(struct ldap_int_thread_poolq_s));
+		sizeof(struct ldap_int_thread_pool_s));
 
 	if (pool == NULL) return(-1);
 
-	pool->ltp_wqs = (struct ldap_int_thread_poolq_s *)(pool+1);
+	pool->ltp_wqs = LDAP_MALLOC(numqs * sizeof(struct ldap_int_thread_poolq_s *));
+	if (pool->ltp_wqs == NULL) {
+		LDAP_FREE(pool);
+		return(-1);
+	}
+
+	for (i=0; i<numqs; i++) {
+		char *ptr = LDAP_MALLOC(sizeof(struct ldap_int_thread_poolq_s) + CACHELINE-1);
+		if (ptr == NULL) {
+			for (--i; i>=0; i--)
+				LDAP_FREE(pool->ltp_wqs[i]->ltp_free);
+			LDAP_FREE(pool->ltp_wqs);
+			LDAP_FREE(pool);
+			return(-1);
+		}
+		pool->ltp_wqs[i] = (struct ldap_int_thread_poolq_s *)(((size_t)ptr + CACHELINE-1) & ~(CACHELINE-1));
+		pool->ltp_wqs[i]->ltp_free = ptr;
+	}
+
 	pool->ltp_numqs = numqs;
 	pool->ltp_conf_max_count = max_threads;
 	if ( !max_threads )
@@ -257,7 +280,7 @@ ldap_pvt_thread_pool_init_q (
 	rem_thr = max_threads % numqs;
 	rem_pend = max_pending % numqs;
 	for ( i=0; i<numqs; i++ ) {
-		pq = &pool->ltp_wqs[i];
+		pq = pool->ltp_wqs[i];
 		pq->ltp_pool = pool;
 		rc = ldap_pvt_thread_mutex_init(&pq->ltp_mutex);
 		if (rc != 0)
@@ -351,18 +374,18 @@ ldap_pvt_thread_pool_submit (
 
 	j = i;
 	while(1) {
-		ldap_pvt_thread_mutex_lock(&pool->ltp_wqs[i].ltp_mutex);
-		if (pool->ltp_wqs[i].ltp_pending_count < pool->ltp_wqs[i].ltp_max_pending) {
+		ldap_pvt_thread_mutex_lock(&pool->ltp_wqs[i]->ltp_mutex);
+		if (pool->ltp_wqs[i]->ltp_pending_count < pool->ltp_wqs[i]->ltp_max_pending) {
 			break;
 		}
-		ldap_pvt_thread_mutex_unlock(&pool->ltp_wqs[i].ltp_mutex);
+		ldap_pvt_thread_mutex_unlock(&pool->ltp_wqs[i]->ltp_mutex);
 		i++;
 		i %= pool->ltp_numqs;
 		if ( i == j )
 			return -1;
 	}
 
-	pq = &pool->ltp_wqs[i];
+	pq = pool->ltp_wqs[i];
 	task = LDAP_SLIST_FIRST(&pq->ltp_free_list);
 	if (task) {
 		LDAP_SLIST_REMOVE_HEAD(&pq->ltp_free_list, ltt_next.l);
@@ -465,7 +488,7 @@ ldap_pvt_thread_pool_retract (
 		return(-1);
 
 	i = ldap_int_poolq_hash( pool, arg );
-	pq = &pool->ltp_wqs[i];
+	pq = pool->ltp_wqs[i];
 
 	ldap_pvt_thread_mutex_lock(&pq->ltp_mutex);
 	LDAP_STAILQ_FOREACH(task, &pq->ltp_pending_list, ltt_next.q)
@@ -482,6 +505,75 @@ ldap_pvt_thread_pool_retract (
 	return task != NULL;
 }
 
+/* Set number of work queues in this pool. Should not be
+ * more than the number of CPUs. */
+int
+ldap_pvt_thread_pool_queues(
+	ldap_pvt_thread_pool_t *tpool,
+	int numqs )
+{
+	struct ldap_int_thread_pool_s *pool;
+	struct ldap_int_thread_poolq_s *pq;
+	int i, rc, rem_thr, rem_pend;
+
+	if (numqs < 1 || tpool == NULL)
+		return(-1);
+
+	pool = *tpool;
+
+	if (pool == NULL)
+		return(-1);
+
+	if (numqs < pool->ltp_numqs) {
+		for (i=numqs; i<pool->ltp_numqs; i++)
+			pool->ltp_wqs[i]->ltp_max_count = 0;
+	} else if (numqs > pool->ltp_numqs) {
+		struct ldap_int_thread_poolq_s **wqs;
+		wqs = LDAP_REALLOC(pool->ltp_wqs, numqs * sizeof(struct ldap_int_thread_poolq_s *));
+		if (wqs == NULL)
+			return(-1);
+		pool->ltp_wqs = wqs;
+		for (i=pool->ltp_numqs; i<numqs; i++) {
+			char *ptr = LDAP_MALLOC(sizeof(struct ldap_int_thread_poolq_s) + CACHELINE-1);
+			if (ptr == NULL) {
+				for (; i<numqs; i++)
+					pool->ltp_wqs[i] = NULL;
+				return(-1);
+			}
+			pq = (struct ldap_int_thread_poolq_s *)(((size_t)ptr + CACHELINE-1) & ~(CACHELINE-1));
+			pq->ltp_free = ptr;
+			pool->ltp_wqs[i] = pq;
+			pq->ltp_pool = pool;
+			rc = ldap_pvt_thread_mutex_init(&pq->ltp_mutex);
+			if (rc != 0)
+				return(rc);
+			rc = ldap_pvt_thread_cond_init(&pq->ltp_cond);
+			if (rc != 0)
+				return(rc);
+			LDAP_STAILQ_INIT(&pq->ltp_pending_list);
+			pq->ltp_work_list = &pq->ltp_pending_list;
+			LDAP_SLIST_INIT(&pq->ltp_free_list);
+		}
+	}
+	rem_thr = pool->ltp_max_count % numqs;
+	rem_pend = pool->ltp_max_pending % numqs;
+	for ( i=0; i<numqs; i++ ) {
+		pq = pool->ltp_wqs[i];
+		pq->ltp_max_count = pool->ltp_max_count / numqs;
+		if ( rem_thr ) {
+			pq->ltp_max_count++;
+			rem_thr--;
+		}
+		pq->ltp_max_pending = pool->ltp_max_pending / numqs;
+		if ( rem_pend ) {
+			pq->ltp_max_pending++;
+			rem_pend--;
+		}
+	}
+	pool->ltp_numqs = numqs;
+	return 0;
+}
+
 /* Set max #threads.  value <= 0 means max supported #threads (LDAP_MAXTHR) */
 int
 ldap_pvt_thread_pool_maxthreads(
@@ -512,14 +604,12 @@ ldap_pvt_thread_pool_maxthreads(
 	max_threads /= pool->ltp_numqs;
 
 	for (i=0; i<pool->ltp_numqs; i++) {
-		pq = &pool->ltp_wqs[i];
-		ldap_pvt_thread_mutex_lock(&pq->ltp_mutex);
+		pq = pool->ltp_wqs[i];
 		pq->ltp_max_count = max_threads;
 		if (remthr) {
 			pq->ltp_max_count++;
 			remthr--;
 		}
-		ldap_pvt_thread_mutex_unlock(&pq->ltp_mutex);
 	}
 	return(0);
 }
@@ -572,7 +662,7 @@ ldap_pvt_thread_pool_query(
 			int i;
 			count = 0;
 			for (i=0; i<pool->ltp_numqs; i++) {
-				struct ldap_int_thread_poolq_s *pq = &pool->ltp_wqs[i];
+				struct ldap_int_thread_poolq_s *pq = pool->ltp_wqs[i];
 				ldap_pvt_thread_mutex_lock(&pq->ltp_mutex);
 				switch(param) {
 					case LDAP_PVT_THREAD_POOL_PARAM_OPEN:
@@ -615,7 +705,7 @@ ldap_pvt_thread_pool_query(
 		else {
 			int i;
 			for (i=0; i<pool->ltp_numqs; i++)
-				if (pool->ltp_wqs[i].ltp_pending_count) break;
+				if (pool->ltp_wqs[i]->ltp_pending_count) break;
 			if (i<pool->ltp_numqs)
 				*((char **)value) = "finishing";
 			else
@@ -706,7 +796,7 @@ ldap_pvt_thread_pool_destroy ( ldap_pvt_thread_pool_t *tpool, int run_pending )
 	ldap_pvt_thread_mutex_unlock(&pool->ltp_mutex);
 
 	for (i=0; i<pool->ltp_numqs; i++) {
-		pq = &pool->ltp_wqs[i];
+		pq = pool->ltp_wqs[i];
 		ldap_pvt_thread_mutex_lock(&pq->ltp_mutex);
 		if (pq->ltp_max_pending > 0)
 			pq->ltp_max_pending = -pq->ltp_max_pending;
@@ -753,7 +843,7 @@ ldap_int_thread_pool_wrapper (
 	ldap_int_tpool_plist_t *work_list;
 	ldap_int_thread_userctx_t ctx, *kctx;
 	unsigned i, keyslot, hash;
-	int pool_lock = 0;
+	int pool_lock = 0, freeme = 0;
 
 	assert(pool != NULL);
 
@@ -869,15 +959,24 @@ ldap_int_thread_pool_wrapper (
 	ldap_pvt_thread_mutex_unlock(&ldap_pvt_thread_pool_mutex);
 
 	pq->ltp_open_count--;
-	/* let pool_destroy know we're all done */
-	if (pq->ltp_open_count == 0)
-		ldap_pvt_thread_cond_signal(&pq->ltp_cond);
+	if (pq->ltp_open_count == 0) {
+		if (pool->ltp_finishing)
+			/* let pool_destroy know we're all done */
+			ldap_pvt_thread_cond_signal(&pq->ltp_cond);
+		else
+			freeme = 1;
+	}
 
 	if (pool_lock)
 		ldap_pvt_thread_mutex_unlock(&pool->ltp_mutex);
 	else
 		ldap_pvt_thread_mutex_unlock(&pq->ltp_mutex);
 
+	if (freeme) {
+		ldap_pvt_thread_cond_destroy(&pq->ltp_cond);
+		ldap_pvt_thread_mutex_destroy(&pq->ltp_mutex);
+		LDAP_FREE(pq->ltp_free);
+	}
 	ldap_pvt_thread_exit(NULL);
 	return(NULL);
 }
@@ -965,7 +1064,7 @@ handle_pause( ldap_pvt_thread_pool_t *tpool, int pause_type )
 		pool->ltp_active_queues = 0;
 
 		for (i=0; i<pool->ltp_numqs; i++)
-			if (&pool->ltp_wqs[i] == pq) break;
+			if (pool->ltp_wqs[i] == pq) break;
 
 		ldap_pvt_thread_mutex_lock(&pq->ltp_mutex);
 		/* temporarily remove ourself from active count */
@@ -973,7 +1072,7 @@ handle_pause( ldap_pvt_thread_pool_t *tpool, int pause_type )
 
 		j=i;
 		do {
-			pq = &pool->ltp_wqs[j];
+			pq = pool->ltp_wqs[j];
 			if (j != i)
 				ldap_pvt_thread_mutex_lock(&pq->ltp_mutex);
 
@@ -998,7 +1097,7 @@ handle_pause( ldap_pvt_thread_pool_t *tpool, int pause_type )
 			ldap_pvt_thread_cond_wait(&pool->ltp_pcond, &pool->ltp_mutex);
 
 		/* restore us to active count */
-		pool->ltp_wqs[i].ltp_active_count++;
+		pool->ltp_wqs[i]->ltp_active_count++;
 
 		assert(pool->ltp_pause == WANT_PAUSE);
 		pool->ltp_pause = PAUSED;
@@ -1065,7 +1164,7 @@ ldap_pvt_thread_pool_resume (
 	assert(pool->ltp_pause == PAUSED);
 	pool->ltp_pause = 0;
 	for (i=0; i<pool->ltp_numqs; i++) {
-		pq = &pool->ltp_wqs[i];
+		pq = pool->ltp_wqs[i];
 		if (pq->ltp_open_count <= 0) /* true when paused, but be paranoid */
 			pq->ltp_open_count = -pq->ltp_open_count;
 		pq->ltp_work_list = &pq->ltp_pending_list;
diff --git a/servers/slapd/bconfig.c b/servers/slapd/bconfig.c
index c760a98..0d62310 100644
--- a/servers/slapd/bconfig.c
+++ b/servers/slapd/bconfig.c
@@ -1717,6 +1717,8 @@ config_generic(ConfigArgs *c) {
 					c->log, c->cr_msg, 0 );
 				return 1;
 			}
+			if ( slapMode & SLAP_SERVER_MODE )
+				ldap_pvt_thread_pool_queues(&connection_pool, c->value_int);
 			connection_pool_queues = c->value_int;	/* save for reference */
 			break;
 
-- 
1.7.4.2
diff --git a/libraries/libldap_r/tpool.c b/libraries/libldap_r/tpool.c
index 87fc0b3..caa96d1 100644
--- a/libraries/libldap_r/tpool.c
+++ b/libraries/libldap_r/tpool.c
@@ -248,7 +248,7 @@ ldap_pvt_thread_pool_init_q (
 	}
 
 	for (i=0; i<numqs; i++) {
-		char *ptr = LDAP_MALLOC(sizeof(struct ldap_int_thread_poolq_s) + CACHELINE-1);
+		char *ptr = LDAP_CALLOC(1, sizeof(struct ldap_int_thread_poolq_s) + CACHELINE-1);
 		if (ptr == NULL) {
 			for (--i; i>=0; i--)
 				LDAP_FREE(pool->ltp_wqs[i]->ltp_free);
@@ -534,7 +539,7 @@ ldap_pvt_thread_pool_queues(
 			return(-1);
 		pool->ltp_wqs = wqs;
 		for (i=pool->ltp_numqs; i<numqs; i++) {
-			char *ptr = LDAP_MALLOC(sizeof(struct ldap_int_thread_poolq_s) + CACHELINE-1);
+			char *ptr = LDAP_CALLOC(1, sizeof(struct ldap_int_thread_poolq_s) + CACHELINE-1);
 			if (ptr == NULL) {
 				for (; i<numqs; i++)
 					pool->ltp_wqs[i] = NULL;

